{"ast":null,"code":"import { initMixpanel } from './mixpanel-service';\nimport { AuthType, EmbedEvent } from './types';\nimport { appendToUrlHash } from './utils'; // eslint-disable-next-line import/no-cycle\n\nimport { fetchSessionInfoService, fetchAuthTokenService, fetchAuthService, fetchBasicAuthService } from './utils/authService'; // eslint-disable-next-line import/no-mutable-exports\n\nexport let loggedInStatus = false; // eslint-disable-next-line import/no-mutable-exports\n\nexport let samlAuthWindow = null; // eslint-disable-next-line import/no-mutable-exports\n\nexport let samlCompletionPromise = null; // eslint-disable-next-line import/no-mutable-exports\n\nexport let sessionInfo = null;\nexport const SSO_REDIRECTION_MARKER_GUID = '5e16222e-ef02-43e9-9fbd-24226bf3ce5b';\nexport const EndPoints = {\n  AUTH_VERIFICATION: '/callosum/v1/session/info',\n  SAML_LOGIN_TEMPLATE: targetUrl => `/callosum/v1/saml/login?targetURLPath=${targetUrl}`,\n  OIDC_LOGIN_TEMPLATE: targetUrl => `/callosum/v1/oidc/login?targetURLPath=${targetUrl}`,\n  TOKEN_LOGIN: '/callosum/v1/session/login/token',\n  BASIC_LOGIN: '/callosum/v1/session/login'\n};\n/**\n * Check if we are logged into the ThoughtSpot cluster\n * @param thoughtSpotHost The ThoughtSpot cluster hostname or IP\n */\n\nasync function isLoggedIn(thoughtSpotHost) {\n  const authVerificationUrl = `${thoughtSpotHost}${EndPoints.AUTH_VERIFICATION}`;\n  let response = null;\n\n  try {\n    response = await fetchSessionInfoService(authVerificationUrl);\n  } catch (e) {\n    return false;\n  }\n\n  return response.status === 200;\n}\n/**\n * Return sessionInfo if available else make a loggedIn check to fetch the sessionInfo\n */\n\n\nexport function getSessionInfo() {\n  return sessionInfo;\n}\nexport function initSession(sessionDetails) {\n  sessionInfo = sessionDetails;\n  initMixpanel(sessionInfo);\n}\n/**\n * Check if we are stuck at the SSO redirect URL\n */\n\nfunction isAtSSORedirectUrl() {\n  return window.location.href.indexOf(SSO_REDIRECTION_MARKER_GUID) >= 0;\n}\n/**\n * Remove the SSO redirect URL marker\n */\n\n\nfunction removeSSORedirectUrlMarker() {\n  // Note (sunny): This will leave a # around even if it was not in the URL\n  // to begin with. Trying to remove the hash by changing window.location will reload\n  // the page which we don't want. We'll live with adding an unnecessary hash to the\n  // parent page URL until we find any use case where that creates an issue.\n  window.location.hash = window.location.hash.replace(SSO_REDIRECTION_MARKER_GUID, '');\n}\n/**\n * Perform token based authentication\n * @param embedConfig The embed configuration\n */\n\n\nexport const doTokenAuth = async embedConfig => {\n  const {\n    thoughtSpotHost,\n    username,\n    authEndpoint,\n    getAuthToken\n  } = embedConfig;\n\n  if (!authEndpoint && !getAuthToken) {\n    throw new Error('Either auth endpoint or getAuthToken function must be provided');\n  }\n\n  const loggedIn = await isLoggedIn(thoughtSpotHost);\n\n  if (!loggedIn) {\n    let authToken = null;\n\n    if (getAuthToken) {\n      authToken = await getAuthToken();\n    } else {\n      const response = await fetchAuthTokenService(authEndpoint);\n      authToken = await response.text();\n    }\n\n    await fetchAuthService(thoughtSpotHost, username, authToken);\n    loggedInStatus = false;\n  }\n\n  loggedInStatus = true;\n};\n/**\n * Perform basic authentication to the ThoughtSpot cluster using the cluster\n * credentials.\n *\n * Warning: This feature is primarily intended for developer testing. It is\n * strongly advised not to use this authentication method in production.\n * @param embedConfig The embed configuration\n */\n\nexport const doBasicAuth = async embedConfig => {\n  const {\n    thoughtSpotHost,\n    username,\n    password\n  } = embedConfig;\n  const loggedIn = await isLoggedIn(thoughtSpotHost);\n\n  if (!loggedIn) {\n    const response = await fetchBasicAuthService(thoughtSpotHost, username, password);\n    loggedInStatus = response.status === 200;\n  }\n\n  loggedInStatus = true;\n};\n\nasync function samlPopupFlow(ssoURL) {\n  document.body.insertAdjacentHTML('beforeend', '<div id=\"ts-saml-auth\"></div>');\n  const authElem = document.getElementById('ts-saml-auth');\n  samlCompletionPromise = samlCompletionPromise || new Promise((resolve, reject) => {\n    window.addEventListener('message', e => {\n      if (e.data.type === EmbedEvent.SAMLComplete) {\n        e.source.close();\n        resolve();\n      }\n    });\n  });\n  authElem.addEventListener('click', () => {\n    if (samlAuthWindow === null || samlAuthWindow.closed) {\n      samlAuthWindow = window.open(ssoURL, '_blank', 'location=no,height=570,width=520,scrollbars=yes,status=yes');\n    } else {\n      samlAuthWindow.focus();\n    }\n  }, {\n    once: true\n  });\n  authElem.click();\n  return samlCompletionPromise;\n}\n/**\n * Perform SAML authentication\n * @param embedConfig The embed configuration\n */\n\n\nconst doSSOAuth = async (embedConfig, ssoEndPoint) => {\n  const {\n    thoughtSpotHost\n  } = embedConfig;\n  const loggedIn = await isLoggedIn(thoughtSpotHost);\n\n  if (loggedIn) {\n    if (isAtSSORedirectUrl()) {\n      removeSSORedirectUrlMarker();\n    }\n\n    loggedInStatus = true;\n    return;\n  } // we have already tried authentication and it did not succeed, restore\n  // the current URL to the original one and invoke the callback.\n\n\n  if (isAtSSORedirectUrl()) {\n    removeSSORedirectUrlMarker();\n    loggedInStatus = false;\n    return;\n  }\n\n  const ssoURL = `${thoughtSpotHost}${ssoEndPoint}`;\n\n  if (embedConfig.noRedirect) {\n    await samlPopupFlow(ssoURL);\n    return;\n  }\n\n  window.location.href = ssoURL;\n};\n\nexport const doSamlAuth = async embedConfig => {\n  const {\n    thoughtSpotHost\n  } = embedConfig; // redirect for SSO, when the SSO authentication is done, this page will be loaded\n  // again and the same JS will execute again.\n\n  const ssoRedirectUrl = embedConfig.noRedirect ? `${thoughtSpotHost}/v2/#/embed/saml-complete` : appendToUrlHash(window.location.href, SSO_REDIRECTION_MARKER_GUID); // bring back the page to the same URL\n\n  const ssoEndPoint = `${EndPoints.SAML_LOGIN_TEMPLATE(encodeURIComponent(ssoRedirectUrl))}`;\n  await doSSOAuth(embedConfig, ssoEndPoint);\n};\nexport const doOIDCAuth = async embedConfig => {\n  const {\n    thoughtSpotHost\n  } = embedConfig; // redirect for SSO, when the SSO authentication is done, this page will be loaded\n  // again and the same JS will execute again.\n\n  const ssoRedirectUrl = embedConfig.noRedirect ? `${thoughtSpotHost}/v2/#/embed/saml-complete` : appendToUrlHash(window.location.href, SSO_REDIRECTION_MARKER_GUID); // bring back the page to the same URL\n\n  const ssoEndPoint = `${EndPoints.OIDC_LOGIN_TEMPLATE(encodeURIComponent(ssoRedirectUrl))}`;\n  await doSSOAuth(embedConfig, ssoEndPoint);\n};\n/**\n * Perform authentication on the ThoughtSpot cluster\n * @param embedConfig The embed configuration\n */\n\nexport const authenticate = async embedConfig => {\n  const {\n    authType\n  } = embedConfig;\n\n  switch (authType) {\n    case AuthType.SSO:\n      return doSamlAuth(embedConfig);\n\n    case AuthType.OIDC:\n      return doOIDCAuth(embedConfig);\n\n    case AuthType.AuthServer:\n      return doTokenAuth(embedConfig);\n\n    case AuthType.Basic:\n      return doBasicAuth(embedConfig);\n\n    default:\n      return Promise.resolve();\n  }\n};\n/**\n * Check if we are authenticated to the ThoughtSpot cluster\n */\n\nexport const isAuthenticated = () => loggedInStatus;","map":{"version":3,"mappings":"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","names":["initMixpanel","AuthType","EmbedEvent","appendToUrlHash","fetchSessionInfoService","fetchAuthTokenService","fetchAuthService","fetchBasicAuthService","loggedInStatus","samlAuthWindow","samlCompletionPromise","sessionInfo","SSO_REDIRECTION_MARKER_GUID","EndPoints","AUTH_VERIFICATION","SAML_LOGIN_TEMPLATE","targetUrl","OIDC_LOGIN_TEMPLATE","TOKEN_LOGIN","BASIC_LOGIN","isLoggedIn","thoughtSpotHost","authVerificationUrl","response","e","status","getSessionInfo","initSession","sessionDetails","isAtSSORedirectUrl","window","location","href","indexOf","removeSSORedirectUrlMarker","hash","replace","doTokenAuth","embedConfig","username","authEndpoint","getAuthToken","Error","loggedIn","authToken","text","doBasicAuth","password","samlPopupFlow","ssoURL","document","body","insertAdjacentHTML","authElem","getElementById","Promise","resolve","reject","addEventListener","data","type","SAMLComplete","source","close","closed","open","focus","once","click","doSSOAuth","ssoEndPoint","noRedirect","doSamlAuth","ssoRedirectUrl","encodeURIComponent","doOIDCAuth","authenticate","authType","SSO","OIDC","AuthServer","Basic","isAuthenticated"],"sources":["/Users/nathan.schroeder/Documents/dev/TSIntegrationDemo/ts-integration-demo/node_modules/@thoughtspot/visual-embed-sdk/src/auth.ts"],"sourcesContent":["import { initMixpanel } from './mixpanel-service';\nimport { AuthType, EmbedConfig, EmbedEvent } from './types';\nimport { appendToUrlHash } from './utils';\n// eslint-disable-next-line import/no-cycle\nimport {\n    fetchSessionInfoService,\n    fetchAuthTokenService,\n    fetchAuthService,\n    fetchBasicAuthService,\n} from './utils/authService';\n\n// eslint-disable-next-line import/no-mutable-exports\nexport let loggedInStatus = false;\n// eslint-disable-next-line import/no-mutable-exports\nexport let samlAuthWindow: Window = null;\n// eslint-disable-next-line import/no-mutable-exports\nexport let samlCompletionPromise: Promise<void> = null;\n// eslint-disable-next-line import/no-mutable-exports\nexport let sessionInfo: any = null;\n\nexport const SSO_REDIRECTION_MARKER_GUID =\n    '5e16222e-ef02-43e9-9fbd-24226bf3ce5b';\n\nexport const EndPoints = {\n    AUTH_VERIFICATION: '/callosum/v1/session/info',\n    SAML_LOGIN_TEMPLATE: (targetUrl: string) =>\n        `/callosum/v1/saml/login?targetURLPath=${targetUrl}`,\n    OIDC_LOGIN_TEMPLATE: (targetUrl: string) =>\n        `/callosum/v1/oidc/login?targetURLPath=${targetUrl}`,\n    TOKEN_LOGIN: '/callosum/v1/session/login/token',\n    BASIC_LOGIN: '/callosum/v1/session/login',\n};\n\n/**\n * Check if we are logged into the ThoughtSpot cluster\n * @param thoughtSpotHost The ThoughtSpot cluster hostname or IP\n */\nasync function isLoggedIn(thoughtSpotHost: string): Promise<boolean> {\n    const authVerificationUrl = `${thoughtSpotHost}${EndPoints.AUTH_VERIFICATION}`;\n    let response = null;\n    try {\n        response = await fetchSessionInfoService(authVerificationUrl);\n    } catch (e) {\n        return false;\n    }\n    return response.status === 200;\n}\n\n/**\n * Return sessionInfo if available else make a loggedIn check to fetch the sessionInfo\n */\nexport function getSessionInfo() {\n    return sessionInfo;\n}\n\nexport function initSession(sessionDetails: any) {\n    sessionInfo = sessionDetails;\n    initMixpanel(sessionInfo);\n}\n\n/**\n * Check if we are stuck at the SSO redirect URL\n */\nfunction isAtSSORedirectUrl(): boolean {\n    return window.location.href.indexOf(SSO_REDIRECTION_MARKER_GUID) >= 0;\n}\n\n/**\n * Remove the SSO redirect URL marker\n */\nfunction removeSSORedirectUrlMarker(): void {\n    // Note (sunny): This will leave a # around even if it was not in the URL\n    // to begin with. Trying to remove the hash by changing window.location will reload\n    // the page which we don't want. We'll live with adding an unnecessary hash to the\n    // parent page URL until we find any use case where that creates an issue.\n    window.location.hash = window.location.hash.replace(\n        SSO_REDIRECTION_MARKER_GUID,\n        '',\n    );\n}\n\n/**\n * Perform token based authentication\n * @param embedConfig The embed configuration\n */\nexport const doTokenAuth = async (embedConfig: EmbedConfig): Promise<void> => {\n    const {\n        thoughtSpotHost,\n        username,\n        authEndpoint,\n        getAuthToken,\n    } = embedConfig;\n    if (!authEndpoint && !getAuthToken) {\n        throw new Error(\n            'Either auth endpoint or getAuthToken function must be provided',\n        );\n    }\n    const loggedIn = await isLoggedIn(thoughtSpotHost);\n    if (!loggedIn) {\n        let authToken = null;\n        if (getAuthToken) {\n            authToken = await getAuthToken();\n        } else {\n            const response = await fetchAuthTokenService(authEndpoint);\n            authToken = await response.text();\n        }\n        await fetchAuthService(thoughtSpotHost, username, authToken);\n        loggedInStatus = false;\n    }\n\n    loggedInStatus = true;\n};\n\n/**\n * Perform basic authentication to the ThoughtSpot cluster using the cluster\n * credentials.\n *\n * Warning: This feature is primarily intended for developer testing. It is\n * strongly advised not to use this authentication method in production.\n * @param embedConfig The embed configuration\n */\nexport const doBasicAuth = async (embedConfig: EmbedConfig): Promise<void> => {\n    const { thoughtSpotHost, username, password } = embedConfig;\n    const loggedIn = await isLoggedIn(thoughtSpotHost);\n    if (!loggedIn) {\n        const response = await fetchBasicAuthService(\n            thoughtSpotHost,\n            username,\n            password,\n        );\n        loggedInStatus = response.status === 200;\n    }\n\n    loggedInStatus = true;\n};\n\nasync function samlPopupFlow(ssoURL: string) {\n    document.body.insertAdjacentHTML(\n        'beforeend',\n        '<div id=\"ts-saml-auth\"></div>',\n    );\n    const authElem = document.getElementById('ts-saml-auth');\n    samlCompletionPromise =\n        samlCompletionPromise ||\n        new Promise<void>((resolve, reject) => {\n            window.addEventListener('message', (e) => {\n                if (e.data.type === EmbedEvent.SAMLComplete) {\n                    (e.source as Window).close();\n                    resolve();\n                }\n            });\n        });\n    authElem.addEventListener(\n        'click',\n        () => {\n            if (samlAuthWindow === null || samlAuthWindow.closed) {\n                samlAuthWindow = window.open(\n                    ssoURL,\n                    '_blank',\n                    'location=no,height=570,width=520,scrollbars=yes,status=yes',\n                );\n            } else {\n                samlAuthWindow.focus();\n            }\n        },\n        { once: true },\n    );\n    authElem.click();\n    return samlCompletionPromise;\n}\n\n/**\n * Perform SAML authentication\n * @param embedConfig The embed configuration\n */\nconst doSSOAuth = async (\n    embedConfig: EmbedConfig,\n    ssoEndPoint: string,\n): Promise<void> => {\n    const { thoughtSpotHost } = embedConfig;\n    const loggedIn = await isLoggedIn(thoughtSpotHost);\n    if (loggedIn) {\n        if (isAtSSORedirectUrl()) {\n            removeSSORedirectUrlMarker();\n        }\n        loggedInStatus = true;\n        return;\n    }\n\n    // we have already tried authentication and it did not succeed, restore\n    // the current URL to the original one and invoke the callback.\n    if (isAtSSORedirectUrl()) {\n        removeSSORedirectUrlMarker();\n        loggedInStatus = false;\n        return;\n    }\n\n    const ssoURL = `${thoughtSpotHost}${ssoEndPoint}`;\n    if (embedConfig.noRedirect) {\n        await samlPopupFlow(ssoURL);\n        return;\n    }\n\n    window.location.href = ssoURL;\n};\n\nexport const doSamlAuth = async (embedConfig: EmbedConfig) => {\n    const { thoughtSpotHost } = embedConfig;\n    // redirect for SSO, when the SSO authentication is done, this page will be loaded\n    // again and the same JS will execute again.\n    const ssoRedirectUrl = embedConfig.noRedirect\n        ? `${thoughtSpotHost}/v2/#/embed/saml-complete`\n        : appendToUrlHash(window.location.href, SSO_REDIRECTION_MARKER_GUID);\n\n    // bring back the page to the same URL\n    const ssoEndPoint = `${EndPoints.SAML_LOGIN_TEMPLATE(\n        encodeURIComponent(ssoRedirectUrl),\n    )}`;\n\n    await doSSOAuth(embedConfig, ssoEndPoint);\n};\n\nexport const doOIDCAuth = async (embedConfig: EmbedConfig) => {\n    const { thoughtSpotHost } = embedConfig;\n    // redirect for SSO, when the SSO authentication is done, this page will be loaded\n    // again and the same JS will execute again.\n    const ssoRedirectUrl = embedConfig.noRedirect\n        ? `${thoughtSpotHost}/v2/#/embed/saml-complete`\n        : appendToUrlHash(window.location.href, SSO_REDIRECTION_MARKER_GUID);\n\n    // bring back the page to the same URL\n    const ssoEndPoint = `${EndPoints.OIDC_LOGIN_TEMPLATE(\n        encodeURIComponent(ssoRedirectUrl),\n    )}`;\n\n    await doSSOAuth(embedConfig, ssoEndPoint);\n};\n\n/**\n * Perform authentication on the ThoughtSpot cluster\n * @param embedConfig The embed configuration\n */\nexport const authenticate = async (embedConfig: EmbedConfig): Promise<void> => {\n    const { authType } = embedConfig;\n    switch (authType) {\n        case AuthType.SSO:\n            return doSamlAuth(embedConfig);\n        case AuthType.OIDC:\n            return doOIDCAuth(embedConfig);\n        case AuthType.AuthServer:\n            return doTokenAuth(embedConfig);\n        case AuthType.Basic:\n            return doBasicAuth(embedConfig);\n        default:\n            return Promise.resolve();\n    }\n};\n\n/**\n * Check if we are authenticated to the ThoughtSpot cluster\n */\nexport const isAuthenticated = (): boolean => loggedInStatus;\n"]},"metadata":{},"sourceType":"module"}