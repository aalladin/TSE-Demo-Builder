{"ast":null,"code":"/* eslint-disable import/no-mutable-exports */\n\n/**\n * Copyright (c) 2022\n *\n * Base classes\n *\n * @summary Base classes\n * @author Ayon Ghosh <ayon.ghosh@thoughtspot.com>\n */\nimport { getThoughtSpotHost } from '../config';\nimport { authenticate } from '../auth';\nimport { uploadMixpanelEvent, MIXPANEL_EVENT } from '../mixpanel-service';\nlet config = {};\nexport let authPromise;\n/**\n * Perform authentication on the ThoughtSpot app as applicable.\n */\n\nexport const handleAuth = () => {\n  const authConfig = { ...config,\n    thoughtSpotHost: getThoughtSpotHost(config)\n  };\n  authPromise = authenticate(authConfig);\n  return authPromise;\n};\nexport const getEmbedConfig = () => config;\nexport const getAuthPromise = () => authPromise;\n/**\n * Prefetches static resources from the specified URL. Web browsers can then cache the prefetched resources and serve them from the user's local disk to provide faster access to your app.\n * @param url The URL provided for prefetch\n */\n\nexport const prefetch = url => {\n  if (url === '') {\n    // eslint-disable-next-line no-console\n    console.warn('The prefetch method does not have a valid URL');\n  } else {\n    const iFrame = document.createElement('iframe');\n    iFrame.src = url || config.thoughtSpotHost;\n    iFrame.style.width = '0';\n    iFrame.style.height = '0';\n    iFrame.style.border = '0';\n    iFrame.classList.add('prefetchIframe');\n    document.body.appendChild(iFrame);\n  }\n};\n/**\n * Initialize the ThoughtSpot embed SDK globally and perform\n * authentication if applicable.\n * @param embedConfig The configuration object containing ThoughtSpot host,\n * authentication mechanism and so on.\n *\n * @returns authPromise Promise which resolves when authentication is complete.\n */\n\nexport const init = embedConfig => {\n  config = embedConfig;\n  handleAuth();\n  uploadMixpanelEvent(MIXPANEL_EVENT.VISUAL_SDK_CALLED_INIT, {\n    authType: config.authType,\n    host: config.thoughtSpotHost\n  });\n\n  if (config.callPrefetch) {\n    prefetch(config.thoughtSpotHost);\n  }\n\n  return authPromise;\n};\nlet renderQueue = Promise.resolve();\n/**\n * Renders functions in a queue, resolves to next function only after the callback next is called\n * @param fn The function being registered\n */\n\nexport const renderInQueue = fn => {\n  const {\n    queueMultiRenders = false\n  } = config;\n\n  if (queueMultiRenders) {\n    renderQueue = renderQueue.then(() => new Promise(res => fn(res)));\n  } else {\n    // Sending an empty function to keep it consistent with the above usage.\n    fn(() => {}); // eslint-disable-line @typescript-eslint/no-empty-function\n  }\n};","map":{"version":3,"mappings":"AAAA;;AACA;;;;;;;;AAQA,SAASA,kBAAT,QAAmC,WAAnC;AAEA,SAASC,YAAT,QAA6B,SAA7B;AACA,SAASC,mBAAT,EAA8BC,cAA9B,QAAoD,qBAApD;AAEA,IAAIC,MAAM,GAAG,EAAb;AAEA,OAAO,IAAIC,WAAJ;AAEP;;;;AAGA,OAAO,MAAMC,UAAU,GAAG,MAAoB;AAC1C,QAAMC,UAAU,GAAG,EACf,GAAGH,MADY;AAEfI,mBAAe,EAAER,kBAAkB,CAACI,MAAD;AAFpB,GAAnB;AAIAC,aAAW,GAAGJ,YAAY,CAACM,UAAD,CAA1B;AACA,SAAOF,WAAP;AACH,CAPM;AASP,OAAO,MAAMI,cAAc,GAAG,MAAmBL,MAA1C;AAEP,OAAO,MAAMM,cAAc,GAAG,MAAqBL,WAA5C;AAEP;;;;;AAIA,OAAO,MAAMM,QAAQ,GAAIC,GAAD,IAAuB;AAC3C,MAAIA,GAAG,KAAK,EAAZ,EAAgB;AACZ;AACAC,WAAO,CAACC,IAAR,CAAa,+CAAb;AACH,GAHD,MAGO;AACH,UAAMC,MAAM,GAAGC,QAAQ,CAACC,aAAT,CAAuB,QAAvB,CAAf;AACAF,UAAM,CAACG,GAAP,GAAaN,GAAG,IAAIR,MAAM,CAACI,eAA3B;AACAO,UAAM,CAACI,KAAP,CAAaC,KAAb,GAAqB,GAArB;AACAL,UAAM,CAACI,KAAP,CAAaE,MAAb,GAAsB,GAAtB;AACAN,UAAM,CAACI,KAAP,CAAaG,MAAb,GAAsB,GAAtB;AACAP,UAAM,CAACQ,SAAP,CAAiBC,GAAjB,CAAqB,gBAArB;AACAR,YAAQ,CAACS,IAAT,CAAcC,WAAd,CAA0BX,MAA1B;AACH;AACJ,CAbM;AAeP;;;;;;;;;AAQA,OAAO,MAAMY,IAAI,GAAIC,WAAD,IAA4C;AAC5DxB,QAAM,GAAGwB,WAAT;AACAtB,YAAU;AAEVJ,qBAAmB,CAACC,cAAc,CAAC0B,sBAAhB,EAAwC;AACvDC,YAAQ,EAAE1B,MAAM,CAAC0B,QADsC;AAEvDC,QAAI,EAAE3B,MAAM,CAACI;AAF0C,GAAxC,CAAnB;;AAKA,MAAIJ,MAAM,CAAC4B,YAAX,EAAyB;AACrBrB,YAAQ,CAACP,MAAM,CAACI,eAAR,CAAR;AACH;;AACD,SAAOH,WAAP;AACH,CAbM;AAeP,IAAI4B,WAAW,GAAiBC,OAAO,CAACC,OAAR,EAAhC;AAEA;;;;;AAIA,OAAO,MAAMC,aAAa,GAAIC,EAAD,IAA6C;AACtE,QAAM;AAAEC,qBAAiB,GAAG;AAAtB,MAAgClC,MAAtC;;AACA,MAAIkC,iBAAJ,EAAuB;AACnBL,eAAW,GAAGA,WAAW,CAACM,IAAZ,CAAiB,MAAM,IAAIL,OAAJ,CAAaM,GAAD,IAASH,EAAE,CAACG,GAAD,CAAvB,CAAvB,CAAd;AACH,GAFD,MAEO;AACH;AACAH,MAAE,CAAC,MAAK,CAAG,CAAT,CAAF,CAFG,CAEW;AACjB;AACJ,CARM","names":["getThoughtSpotHost","authenticate","uploadMixpanelEvent","MIXPANEL_EVENT","config","authPromise","handleAuth","authConfig","thoughtSpotHost","getEmbedConfig","getAuthPromise","prefetch","url","console","warn","iFrame","document","createElement","src","style","width","height","border","classList","add","body","appendChild","init","embedConfig","VISUAL_SDK_CALLED_INIT","authType","host","callPrefetch","renderQueue","Promise","resolve","renderInQueue","fn","queueMultiRenders","then","res"],"sources":["/Users/nathan.schroeder/Documents/dev/ts-integration-demo/node_modules/@thoughtspot/visual-embed-sdk/src/embed/base.ts"],"sourcesContent":["/* eslint-disable import/no-mutable-exports */\n/**\n * Copyright (c) 2022\n *\n * Base classes\n *\n * @summary Base classes\n * @author Ayon Ghosh <ayon.ghosh@thoughtspot.com>\n */\nimport { getThoughtSpotHost } from '../config';\nimport { EmbedConfig } from '../types';\nimport { authenticate } from '../auth';\nimport { uploadMixpanelEvent, MIXPANEL_EVENT } from '../mixpanel-service';\n\nlet config = {} as EmbedConfig;\n\nexport let authPromise: Promise<void>;\n\n/**\n * Perform authentication on the ThoughtSpot app as applicable.\n */\nexport const handleAuth = (): Promise<void> => {\n    const authConfig = {\n        ...config,\n        thoughtSpotHost: getThoughtSpotHost(config),\n    };\n    authPromise = authenticate(authConfig);\n    return authPromise;\n};\n\nexport const getEmbedConfig = (): EmbedConfig => config;\n\nexport const getAuthPromise = (): Promise<void> => authPromise;\n\n/**\n * Prefetches static resources from the specified URL. Web browsers can then cache the prefetched resources and serve them from the user's local disk to provide faster access to your app.\n * @param url The URL provided for prefetch\n */\nexport const prefetch = (url?: string): void => {\n    if (url === '') {\n        // eslint-disable-next-line no-console\n        console.warn('The prefetch method does not have a valid URL');\n    } else {\n        const iFrame = document.createElement('iframe');\n        iFrame.src = url || config.thoughtSpotHost;\n        iFrame.style.width = '0';\n        iFrame.style.height = '0';\n        iFrame.style.border = '0';\n        iFrame.classList.add('prefetchIframe');\n        document.body.appendChild(iFrame);\n    }\n};\n\n/**\n * Initialize the ThoughtSpot embed SDK globally and perform\n * authentication if applicable.\n * @param embedConfig The configuration object containing ThoughtSpot host,\n * authentication mechanism and so on.\n *\n * @returns authPromise Promise which resolves when authentication is complete.\n */\nexport const init = (embedConfig: EmbedConfig): Promise<void> => {\n    config = embedConfig;\n    handleAuth();\n\n    uploadMixpanelEvent(MIXPANEL_EVENT.VISUAL_SDK_CALLED_INIT, {\n        authType: config.authType,\n        host: config.thoughtSpotHost,\n    });\n\n    if (config.callPrefetch) {\n        prefetch(config.thoughtSpotHost);\n    }\n    return authPromise;\n};\n\nlet renderQueue: Promise<any> = Promise.resolve();\n\n/**\n * Renders functions in a queue, resolves to next function only after the callback next is called\n * @param fn The function being registered\n */\nexport const renderInQueue = (fn: (next?: (val?: any) => void) => void) => {\n    const { queueMultiRenders = false } = config;\n    if (queueMultiRenders) {\n        renderQueue = renderQueue.then(() => new Promise((res) => fn(res)));\n    } else {\n        // Sending an empty function to keep it consistent with the above usage.\n        fn(() => {}); // eslint-disable-line @typescript-eslint/no-empty-function\n    }\n};\n"]},"metadata":{},"sourceType":"module"}