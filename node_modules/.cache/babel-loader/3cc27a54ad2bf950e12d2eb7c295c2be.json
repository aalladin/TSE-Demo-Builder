{"ast":null,"code":"/**\n * Copyright (c) 2022\n *\n * Common utility functions for ThoughtSpot Visual Embed SDK\n *\n * @summary Utils\n * @author Ayon Ghosh <ayon.ghosh@thoughtspot.com>\n */\n\n/**\n * Construct a runtime filters query string from the given filters.\n * Refer to the following docs for more details on runtime filter syntax:\n * https://cloud-docs.thoughtspot.com/admin/ts-cloud/apply-runtime-filter.html\n * https://cloud-docs.thoughtspot.com/admin/ts-cloud/runtime-filter-operators.html\n * @param runtimeFilters\n */\nexport const getFilterQuery = runtimeFilters => {\n  if (runtimeFilters && runtimeFilters.length) {\n    const filters = runtimeFilters.map((filter, valueIndex) => {\n      const index = valueIndex + 1;\n      const filterExpr = [];\n      filterExpr.push(`col${index}=${filter.columnName}`);\n      filterExpr.push(`op${index}=${filter.operator}`);\n      filterExpr.push(filter.values.map(value => `val${index}=${value}`).join('&'));\n      return filterExpr.join('&');\n    });\n    return `${filters.join('&')}`;\n  }\n\n  return null;\n};\n/**\n * Convert a value to a string representation to be sent as a query\n * parameter to the ThoughtSpot app.\n * @param value Any parameter value\n */\n\nconst serializeParam = value => {\n  // do not serialize primitive types\n  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n    return value;\n  }\n\n  return JSON.stringify(value);\n};\n/**\n * Convert a value to a string:\n * in case of an array, we convert it to CSV.\n * in case of any other type, we directly return the value.\n * @param value\n */\n\n\nconst paramToString = value => Array.isArray(value) ? value.join(',') : value;\n/**\n * Return a query param string composed from the given params object\n * @param queryParams\n */\n\n\nexport const getQueryParamString = function (queryParams) {\n  let shouldSerializeParamValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const qp = [];\n  const params = Object.keys(queryParams);\n  params.forEach(key => {\n    const val = queryParams[key];\n\n    if (val !== undefined) {\n      const serializedValue = shouldSerializeParamValues ? serializeParam(val) : paramToString(val);\n      qp.push(`${key}=${serializedValue}`);\n    }\n  });\n\n  if (qp.length) {\n    return qp.join('&');\n  }\n\n  return null;\n};\n/**\n * Get a string representation of a dimension value in CSS\n * If numeric, it is considered in pixels.\n * @param value\n */\n\nexport const getCssDimension = value => {\n  if (typeof value === 'number') {\n    return `${value}px`;\n  }\n\n  return value;\n};\n/**\n * Append a string to a URL's hash fragment\n * @param url A URL\n * @param stringToAppend The string to append to the URL hash\n */\n\nexport const appendToUrlHash = (url, stringToAppend) => {\n  let outputUrl = url;\n  const encStringToAppend = encodeURIComponent(stringToAppend);\n\n  if (url.indexOf('#') >= 0) {\n    outputUrl = `${outputUrl}${encStringToAppend}`;\n  } else {\n    outputUrl = `${outputUrl}#${encStringToAppend}`;\n  }\n\n  return outputUrl;\n};\nexport const getEncodedQueryParamsString = queryString => {\n  if (!queryString) {\n    return queryString;\n  }\n\n  return btoa(queryString).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n};\nexport const getOffsetTop = element => {\n  const rect = element.getBoundingClientRect();\n  return rect.top + window.scrollY;\n};","map":{"version":3,"mappings":"AAAA;;;;;;;;;AAWA;;;;;;;AAOA,OAAO,MAAMA,cAAc,GAAIC,cAAD,IAA4C;AACtE,MAAIA,cAAc,IAAIA,cAAc,CAACC,MAArC,EAA6C;AACzC,UAAMC,OAAO,GAAGF,cAAc,CAACG,GAAf,CAAmB,CAACC,MAAD,EAASC,UAAT,KAAuB;AACtD,YAAMC,KAAK,GAAGD,UAAU,GAAG,CAA3B;AACA,YAAME,UAAU,GAAG,EAAnB;AACAA,gBAAU,CAACC,IAAX,CAAgB,MAAMF,KAAK,IAAIF,MAAM,CAACK,UAAU,EAAhD;AACAF,gBAAU,CAACC,IAAX,CAAgB,KAAKF,KAAK,IAAIF,MAAM,CAACM,QAAQ,EAA7C;AACAH,gBAAU,CAACC,IAAX,CACIJ,MAAM,CAACO,MAAP,CAAcR,GAAd,CAAmBS,KAAD,IAAW,MAAMN,KAAK,IAAIM,KAAK,EAAjD,EAAqDC,IAArD,CAA0D,GAA1D,CADJ;AAIA,aAAON,UAAU,CAACM,IAAX,CAAgB,GAAhB,CAAP;AACH,KAVe,CAAhB;AAYA,WAAO,GAAGX,OAAO,CAACW,IAAR,CAAa,GAAb,CAAiB,EAA3B;AACH;;AAED,SAAO,IAAP;AACH,CAlBM;AAoBP;;;;;;AAKA,MAAMC,cAAc,GAAIF,KAAD,IAAe;AAClC;AACA,MACI,OAAOA,KAAP,KAAiB,QAAjB,IACA,OAAOA,KAAP,KAAiB,QADjB,IAEA,OAAOA,KAAP,KAAiB,SAHrB,EAIE;AACE,WAAOA,KAAP;AACH;;AAED,SAAOG,IAAI,CAACC,SAAL,CAAeJ,KAAf,CAAP;AACH,CAXD;AAaA;;;;;;;;AAMA,MAAMK,aAAa,GAAIL,KAAD,IAClBM,KAAK,CAACC,OAAN,CAAcP,KAAd,IAAuBA,KAAK,CAACC,IAAN,CAAW,GAAX,CAAvB,GAAyCD,KAD7C;AAGA;;;;;;AAIA,OAAO,MAAMQ,mBAAmB,GAAG,UAC/BC,WAD+B,EAGvB;AAAA,MADRC,0BACQ,uEADqB,KACrB;AACR,QAAMC,EAAE,GAAa,EAArB;AACA,QAAMC,MAAM,GAAGC,MAAM,CAACC,IAAP,CAAYL,WAAZ,CAAf;AACAG,QAAM,CAACG,OAAP,CAAgBC,GAAD,IAAQ;AACnB,UAAMC,GAAG,GAAGR,WAAW,CAACO,GAAD,CAAvB;;AACA,QAAIC,GAAG,KAAKC,SAAZ,EAAuB;AACnB,YAAMC,eAAe,GAAGT,0BAA0B,GAC5CR,cAAc,CAACe,GAAD,CAD8B,GAE5CZ,aAAa,CAACY,GAAD,CAFnB;AAGAN,QAAE,CAACf,IAAH,CAAQ,GAAGoB,GAAG,IAAIG,eAAe,EAAjC;AACH;AACJ,GARD;;AAUA,MAAIR,EAAE,CAACtB,MAAP,EAAe;AACX,WAAOsB,EAAE,CAACV,IAAH,CAAQ,GAAR,CAAP;AACH;;AAED,SAAO,IAAP;AACH,CArBM;AAuBP;;;;;;AAKA,OAAO,MAAMmB,eAAe,GAAIpB,KAAD,IAAmC;AAC9D,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC3B,WAAO,GAAGA,KAAK,IAAf;AACH;;AAED,SAAOA,KAAP;AACH,CANM;AAQP;;;;;;AAKA,OAAO,MAAMqB,eAAe,GAAG,CAACC,GAAD,EAAcC,cAAd,KAAwC;AACnE,MAAIC,SAAS,GAAGF,GAAhB;AACA,QAAMG,iBAAiB,GAAGC,kBAAkB,CAACH,cAAD,CAA5C;;AAEA,MAAID,GAAG,CAACK,OAAJ,CAAY,GAAZ,KAAoB,CAAxB,EAA2B;AACvBH,aAAS,GAAG,GAAGA,SAAS,GAAGC,iBAAiB,EAA5C;AACH,GAFD,MAEO;AACHD,aAAS,GAAG,GAAGA,SAAS,IAAIC,iBAAiB,EAA7C;AACH;;AAED,SAAOD,SAAP;AACH,CAXM;AAaP,OAAO,MAAMI,2BAA2B,GAAIC,WAAD,IAAwB;AAC/D,MAAI,CAACA,WAAL,EAAkB;AACd,WAAOA,WAAP;AACH;;AACD,SAAOC,IAAI,CAACD,WAAD,CAAJ,CACFE,OADE,CACM,KADN,EACa,GADb,EAEFA,OAFE,CAEM,KAFN,EAEa,GAFb,EAGFA,OAHE,CAGM,KAHN,EAGa,EAHb,CAAP;AAIH,CARM;AAUP,OAAO,MAAMC,YAAY,GAAIC,OAAD,IAAiB;AACzC,QAAMC,IAAI,GAAGD,OAAO,CAACE,qBAAR,EAAb;AACA,SAAOD,IAAI,CAACE,GAAL,GAAWC,MAAM,CAACC,OAAzB;AACH,CAHM","names":["getFilterQuery","runtimeFilters","length","filters","map","filter","valueIndex","index","filterExpr","push","columnName","operator","values","value","join","serializeParam","JSON","stringify","paramToString","Array","isArray","getQueryParamString","queryParams","shouldSerializeParamValues","qp","params","Object","keys","forEach","key","val","undefined","serializedValue","getCssDimension","appendToUrlHash","url","stringToAppend","outputUrl","encStringToAppend","encodeURIComponent","indexOf","getEncodedQueryParamsString","queryString","btoa","replace","getOffsetTop","element","rect","getBoundingClientRect","top","window","scrollY"],"sources":["/Users/nathan.schroeder/Documents/dev/ts-integration-demo/node_modules/@thoughtspot/visual-embed-sdk/src/utils.ts"],"sourcesContent":["/**\n * Copyright (c) 2022\n *\n * Common utility functions for ThoughtSpot Visual Embed SDK\n *\n * @summary Utils\n * @author Ayon Ghosh <ayon.ghosh@thoughtspot.com>\n */\n\nimport { QueryParams, RuntimeFilter } from './types';\n\n/**\n * Construct a runtime filters query string from the given filters.\n * Refer to the following docs for more details on runtime filter syntax:\n * https://cloud-docs.thoughtspot.com/admin/ts-cloud/apply-runtime-filter.html\n * https://cloud-docs.thoughtspot.com/admin/ts-cloud/runtime-filter-operators.html\n * @param runtimeFilters\n */\nexport const getFilterQuery = (runtimeFilters: RuntimeFilter[]): string => {\n    if (runtimeFilters && runtimeFilters.length) {\n        const filters = runtimeFilters.map((filter, valueIndex) => {\n            const index = valueIndex + 1;\n            const filterExpr = [];\n            filterExpr.push(`col${index}=${filter.columnName}`);\n            filterExpr.push(`op${index}=${filter.operator}`);\n            filterExpr.push(\n                filter.values.map((value) => `val${index}=${value}`).join('&'),\n            );\n\n            return filterExpr.join('&');\n        });\n\n        return `${filters.join('&')}`;\n    }\n\n    return null;\n};\n\n/**\n * Convert a value to a string representation to be sent as a query\n * parameter to the ThoughtSpot app.\n * @param value Any parameter value\n */\nconst serializeParam = (value: any) => {\n    // do not serialize primitive types\n    if (\n        typeof value === 'string' ||\n        typeof value === 'number' ||\n        typeof value === 'boolean'\n    ) {\n        return value;\n    }\n\n    return JSON.stringify(value);\n};\n\n/**\n * Convert a value to a string:\n * in case of an array, we convert it to CSV.\n * in case of any other type, we directly return the value.\n * @param value\n */\nconst paramToString = (value: any) =>\n    Array.isArray(value) ? value.join(',') : value;\n\n/**\n * Return a query param string composed from the given params object\n * @param queryParams\n */\nexport const getQueryParamString = (\n    queryParams: QueryParams,\n    shouldSerializeParamValues = false,\n): string => {\n    const qp: string[] = [];\n    const params = Object.keys(queryParams);\n    params.forEach((key) => {\n        const val = queryParams[key];\n        if (val !== undefined) {\n            const serializedValue = shouldSerializeParamValues\n                ? serializeParam(val)\n                : paramToString(val);\n            qp.push(`${key}=${serializedValue}`);\n        }\n    });\n\n    if (qp.length) {\n        return qp.join('&');\n    }\n\n    return null;\n};\n\n/**\n * Get a string representation of a dimension value in CSS\n * If numeric, it is considered in pixels.\n * @param value\n */\nexport const getCssDimension = (value: number | string): string => {\n    if (typeof value === 'number') {\n        return `${value}px`;\n    }\n\n    return value;\n};\n\n/**\n * Append a string to a URL's hash fragment\n * @param url A URL\n * @param stringToAppend The string to append to the URL hash\n */\nexport const appendToUrlHash = (url: string, stringToAppend: string) => {\n    let outputUrl = url;\n    const encStringToAppend = encodeURIComponent(stringToAppend);\n\n    if (url.indexOf('#') >= 0) {\n        outputUrl = `${outputUrl}${encStringToAppend}`;\n    } else {\n        outputUrl = `${outputUrl}#${encStringToAppend}`;\n    }\n\n    return outputUrl;\n};\n\nexport const getEncodedQueryParamsString = (queryString: string) => {\n    if (!queryString) {\n        return queryString;\n    }\n    return btoa(queryString)\n        .replace(/\\+/g, '-')\n        .replace(/\\//g, '_')\n        .replace(/=+$/, '');\n};\n\nexport const getOffsetTop = (element: any) => {\n    const rect = element.getBoundingClientRect();\n    return rect.top + window.scrollY;\n};\n"]},"metadata":{},"sourceType":"module"}